---
title: "Exploratory analysis pipeline"
author: "German Novakovskiy"
date: "December 14, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, results='hide'}
library(BiocParallel)
library(clusterExperiment)
library(scone)
library(zinbwave)

library(slingshot)
library(doParallel)
library(gam)
library(RColorBrewer)
library(dplyr)
library(edgeR)
library(scater)

#for feature-barcode-matrix loading
library(Matrix)
```
[10X Genomics](https://ucdavis-bioinformatics-training.github.io/2017_2018-single-cell-RNA-sequencing-Workshop-UCD_UCB_UCSF/day1/Expression_Matrix.html)

Analysis of Francis's data: differentiation of hESC towards DE; one time point - 36 hours. 10X Genomics data, The 10X Genomics Chromium system analyses the 3'-ends of transcripts. This leads to a more cost effective analysis of gene expression from thousands of cells. 

Samples:

Sox17-mNeonGreen H1 cells, 24h culture w/ Activin A+CHIR -> 12h culture Activin A+1/10CHIR;

Day 1:  RB + 0.2% FBS + 1:5000 ITS +100ng/mL Activin A + 3uM CHIR99021

Next 12 hours: RB + 0.2% FBS + 1:2000 ITS +100ng/mL Activin A + 0.3uM CHIR99021

*RB: RPMI1640 + 1x Glutamax + 1/200 Penicillin/Streptomycin

Process:

- Added mNeonGreen into GRCh38 as reference

(Follow the instruction on 10xGenomics)

- Run cellranger mkfastq

- Run cellranger count

The 10X Genomics workflow for single cell RNA-seq is shown [here](https://community.10xgenomics.com/t5/10x-Blog/Single-Cell-RNA-Seq-An-Introductory-Overview-and-Tools-for/ba-p/547).

## Pre-processing

Information about input data formats can be found [here](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices).

MEX matrix is sparse matrix. I have 33539 genes and 6320 cells (barcode of which was identified), overall it's 33539*6320 matrix with 211966480 elements. However, matrix.mtx.gz contains pointers only to non-zero elements: 15780312 (7.5%).

Note: There is a problem in the pipeline: Low Fraction Reads in Cells (50.2%). Ideal > 70%. Application performance may be affected. Many of the reads were not assigned to cell-associated barcodes. This could be caused by high levels of ambient RNA or by a significant population of cells with a low RNA content, which the algorithm did not call as cells. 

Loading the data:
```{r}
#getwd()
#UMI counts are not normalized
matrix_dir <-  "../../Sox17Ng_36h_German/filtered_feature_bc_matrix/"

barcode.path <- paste0(matrix_dir, "barcodes.tsv.gz")
features.path <- paste0(matrix_dir, "features.tsv.gz")
matrix.path <- paste0(matrix_dir, "matrix.mtx.gz")

mat <- readMM(file = matrix.path)
feature.names <- read.delim(features.path, 
                           header = FALSE,
                           stringsAsFactors = FALSE)
barcode.names <-  read.delim(barcode.path, 
                           header = FALSE,
                           stringsAsFactors = FALSE)

colnames(mat) <-  barcode.names$V1
rownames(mat) <-  feature.names$V1

#rm(barcode.names, feature.names)

#doing all this in one line
#molecules <- read10X(mtx = "../../Sox17Ng_36h_German/filtered_feature_bc_matrix/matrix.mtx.gz", genes =
#            "../../Sox17Ng_36h_German/filtered_feature_bc_matrix/features.tsv.gz", barcodes =
#            "../../Sox17Ng_36h_German/filtered_feature_bc_matrix/barcodes.tsv.gz", path = NULL, DGEList = FALSE)

```

We didn't use any spike-ins. 
```{r}
umi <- SingleCellExperiment(assays = list(counts = mat))
umi
```
```{r}
keep_feature <- rowSums(counts(umi) > 0) > 0
umi <- umi[keep_feature, ]
dim(umi)
```


Mat is sparse matrix that has only positions of non-zero elements
```{r}
# Remove undetected genes
mat <- na.omit(mat)
mat <- mat[rowSums(mat)>0,]
dim(mat)
```
```{r}
#converting gene column to actual gene symbols (removing GRCh38____)
x <- sapply(feature.names$V2, function(x){unlist(strsplit(x, split = "_____", fixed=TRUE))[2]})
names(x) <- NULL
x[1] <- "mNeonGreen"
feature.names$V4 <- x
rm(x)
```

Define control features (genes) - mitochondrial genes from [here](http://jdblischak.github.io/singleCellSeq/analysis/qc-filter-ipsc.html).

```{r}
mitochondrial_genes <- c("GRCh38_____ENSG00000198899", "GRCh38_____ENSG00000198727", "GRCh38_____ENSG00000198888",
    "GRCh38_____ENSG00000198886", "GRCh38_____ENSG00000212907", "GRCh38_____ENSG00000198786",
    "GRCh38_____ENSG00000198695", "GRCh38_____ENSG00000198712", "GRCh38_____ENSG00000198804",
    "GRCh38_____ENSG00000198763", "GRCh38_____ENSG00000228253", "GRCh38_____ENSG00000198938",
    "GRCh38_____ENSG00000198840")


isSpike(umi, "MT") <- rownames(umi) %in% mitochondrial_genes
```

Calculate the quality metrics:
```{r}
umi <- calculateQCMetrics(
    umi,
    feature_controls = list( 
        MT = isSpike(umi, "MT")
    )
)
```
Next we consider the total number of RNA molecules (since we have UMI here) detected per sample. Wells with few reads/molecules are likely to have been broken or failed to capture a cell, and should thus be removed.
```{r}
hist(
    umi$total_counts,
    breaks = 100
)
abline(v = 10000, col = "red")
```
(2700 cells have UMI counts more than 10000...).
```{r}
table(umi$total_counts > 10000)
```

In addition to ensuring sufficient sequencing depth for each sample, we also want to make sure that the reads are distributed across the transcriptome. Thus, we count the total number of unique genes detected in each sample. 

The average number of genes detected per cell really depends on the cell type. Large, fast growing cells like those from culture or from tumours will often have 5,000 or more genes detected per cell on average. Primary immune cells that are smaller, and less transcriptionally active may only have 1,000 to 3,000 genes detected per cell.
```{r}
#total_features_by_counts - the number of genes that have expression values above the detection limit
hist(
    umi$total_features_by_counts,
    breaks = 100
)
abline(v = 3000, col = "red")
```
(2659 cells have more than 3000 of identified genes...).
```{r}
table(umi$total_features_by_counts > 3000)
```

Ratio between MT gene RNAs and endogenous RNAs:
```{r}
plotColData(se, x="total_features_by_counts_endogenous", y="pct_counts_MT")
#abline(h = 10, col = "red")
```
We see that there is a big fraction of cells, with high expression of mitochondrial genes (>10% of total counts in a cell). Here
is the [reference](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0888-1) of why it's bad:

There is an extensive literature on the relationship between mtDNA, mitochondrially localized proteins, and cell death [34, 35]. However, upregulation of RNA levels of mtDNA in broken cells suggests losses in cytoplasmic content. In a situation where cell membrane is broken, cytoplasmic RNA will be lost, but RNAs enclosed in the mitochondria will be retained.

```{r}
#removing cells where >10% of total counts in a cell are MT genes. (2051 of such cells)
#filter by MT
keep_feature <- se$pct_counts_MT < 10
se <- se[,keep_feature]
dim(se)
```
```{r}
plotColData(se, x="total_features_by_counts_endogenous", y="pct_counts_MT")
#abline(h = 10, col = "red")
```
```{r}
#filter by molecule counts
keep_feature <- se$total_counts < 10000
se <- se[,keep_feature]
dim(se)
```
```{r}
#total_features_by_counts_endogenous
keep_feature <- se$total_features_by_counts_endogenous < 1000
se <- se[,keep_feature]
dim(se)
```
```{r}
assay(se, "logcounts") <- log2(counts(se) + 1)
sepca <- plotPCA(se,
              size_by = "total_features_by_counts"
              #pca_data_input = "pdata",
              #detect_outliers = TRUE
              #return_SCE = TRUE
)
sepca
```
```{r}
plotHighestExprs(se)
```


Using scone, I  remove  low-quality  cells  according  to  the  quality  control  filter implemented  in  the  function 
metric_sample_filter and  based  on  the  following  criteria:  
1. Filter  out samples with low total number of reads or low alignment percentage; 
2. Filter out samples with a low detection rate for housekeeping genes.

Note: we are using UMI counts. Each transcript molecule can only produce one UMI count but can yield many reads after fragmentation. Thus, we see lower amount of UMI counts than read counts (83,374,678 UMI counts compared to 455,682,211):
```{r}
data("housekeeping")

#converting gene column to actual gene symbols (removing GRCh38____)
x <- sapply(feature.names$V2, function(x){unlist(strsplit(x, split = "_____", fixed=TRUE))[2]})
names(x) <- NULL
x[1] <- "mNeonGreen"
feature.names$V4 <- x
rm(x)

#extracting ENSEMBLE gene symbols for housekeeping genes
x <- feature.names %>% filter(V4 %in% housekeeping$V1) %>% select(V1) 
hk <- rownames(se)[rownames(se) %in% x$V1]

expr <- assay(se)
pos_controls <- rownames(expr) %in% hk

mfilt <- metric_sample_filter(expr, nreads = colSums(expr), #pos_controls = pos_controls, 
                              zcut = 3, mixture = FALSE, plot = TRUE)
```
```{r}
rm(expr)
# Simplify to a single logical
mfilt <- !apply(simplify2array(mfilt[!is.na(mfilt)]), 1, any)
se <- se[, mfilt]
dim(se)
```

